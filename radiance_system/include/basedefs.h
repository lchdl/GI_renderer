#pragma once

#include "global.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <errno.h>
#include <new> /* for using replacement new */
#include "basemath.h"

#ifdef _WIN32
#define NOMINMAX
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <unistd.h>
#endif

int getNumProcessors();

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned long DWORD;

/* define DEBUG_BREAK macro based on platform or compiler.      */
/* Current supported platforms: WINDOWS or LINUX-based systems. */
#if defined(_MSC_VER) /* if compile this program on MSVC/VS IDE */
#define DEBUG_BREAK __debugbreak(); /* then use builtin function */
#elif defined(__linux__)
#include <signal.h>
#define DEBUG_BREAK raise(SIGTRAP); /* else we use raise(...) */
#else
#error "Cannot define DEBUG_BREAK macro due to unknown platform or compiler."
#endif

/* DEBUG_BREAK must be correctly defined before defining */
/* the following macro below.                            */
#if defined(_DEBUG) || defined(DEBUG) || defined(DEBUG_MODE)
#define debugCheck(condition, message)                          \
{                                                               \
	if ( (condition) == false ){                                \
		printf("%s\n", message);                                \
		DEBUG_BREAK;                                            \
	}                                                           \
}
#else
#define debugCheck(condition, message) 
#endif

template <typename T>
void swap(T& a, T& b) { T c = a; a = b; b = c; }

template <typename T>
int _pivot(T* arr, const int& L, const int& R) 
{
    /* sort an array from small to large */
    //printf("%d %d\n", L, R);
    if (R - L <= 1) return L;
    const int pivot = R - 1;
    int l = R - 1, r = -1;
    for (int i = L; i < R - 1; i++) {
        if (arr[i] > arr[pivot]) {
            /* if cur > pivot, set left */
            l = i;
            /* find an element smaller than pivot */
            bool find = false;
            for (int j = i + 1; j < R - 1; j++) {
                r = j;
                if (arr[r] < arr[pivot]) {
                    swap(arr[l], arr[r]);
                    find = true;
                    break;
                }
            }
            if (!find) {
                /* all elements between left and pivot are larger than pivot */
                /* just break the loop to swap left and pivot and we are done. */
                break;
            }
        }
    }
    swap(arr[l], arr[pivot]);
    /* now all elements smaller than the pivot are on the left side, */
    /* all elements larger than the pivot are on the right side */
    return l;
}

/* sort array from [start, end) */
template <typename T>
void quickSort(T* arr, int start, int end) {
    if (start < end) {
        int* stack = new int[2 * (end - start + 1)];
        int top = -1;

        stack[++top] = start;
        stack[++top] = end;

        while (top >= 0) {
            end = stack[top--];
            start = stack[top--];

            int mid = _pivot(arr, start, end);
            if (mid - start > 1) {
                /* still contain some elements on the left */
                stack[++top] = start;
                stack[++top] = mid;
            }
            if (end - mid > 1) {
                /* still contain some elements on the right */
                stack[++top] = mid+1;
                stack[++top] = end;
            }
        }
        delete[] stack;
    }
}

template <typename T>
void quickSort(T* arr, int n) 
{
    quickSort(arr, 0, n);
}

/* * * * * * * * * * * * * * * * * * * * * * */
/* simple array exactly like C++ STL vector  */
/*   but I want to implement it myself :)    */
/* * * * * * * * * * * * * * * * * * * * * * */
template <typename T>
class Array {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions generated by the compiler.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

public:

    Array() { baseptr = NULL; Ne = 0; Me = 0; }
    Array(const Array& that) {
        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty array */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if array element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
    }
    virtual ~Array() { this->clear(); }

    Array& operator=(const Array& that) {
        if (this == &that)
            return (*this); /* in case "a = a" will cause unexpected behavior */

        clear();

        this->Ne = that.Ne;
        this->Me = that.Ne; /* NOTE: use "that.Ne" instead of "that.Me" !!! */
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty array */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if array element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
        return (*this);
    }

public:

    T& at(const int& index) {
        return baseptr[index];
    }
    const T& at(const int& index) const {
        return baseptr[index];
    }
    T& operator[](const int& index) {
        return baseptr[index];
    }
    const T& operator[](const int& index) const {
        return baseptr[index];
    }

    /* retrieve the last element (most recently added) */
    T& last() {
        return baseptr[size() - 1];
    }
    const T& last() const {
        return baseptr[size() - 1];
    }
    bool append(T& elem) {
        if (Ne == Me) { /* array is full, expand it */
            if (expandStorage() == false)
                return false;
        }
        new (&(this->baseptr[Ne])) T(); /* init array last element and
                                           prepare for assignment later */
        baseptr[Ne] = elem; /* may invoke: T& operator=(T& elem) */
        Ne++;
        return true; /* normally append() will always success */
    }
    bool append(const T& elem) {
        if (Ne == Me) { 
            /* array is full, expand it */
            if (expandStorage() == false)
                return false;
        }
        new (&(this->baseptr[Ne])) T(); /* init array last element and
                                           prepare for assignment later */
        baseptr[Ne] = elem; /* may invoke: T& operator=(const T& elem) */
        Ne++;
        return true; /* normally append() will always success */
    }
    bool append(const Array<T>& arr) {
        for (int i = 0; i < arr.size(); i++)
            append(arr[i]);
        return true;
    }
    /* add an instance to array (for noncopyable objects) */
    int append()
    {

    }

    bool popLast(T& elem)
    {
        if (Ne == 0) {
            /* already empty, cannot pop any element */
            return false;
        }
        else {
            Ne--;
            elem = baseptr[Ne];
            baseptr[Ne].~T();
            return true;
        }
    }
    bool popLast()
    {
        if (Ne == 0) {
            /* already empty, cannot pop any element */
            return false;
        }
        else {
            Ne--;
            baseptr[Ne].~T();
            return true;
        }
    }

    void clear(bool reserve = false) {
        /* if each element in the array is a class instance,     */
        /* we need to manually call destructor for each instance */
        /* in order to release memory propoerly (especially when */
        /* class instance member contains pointer(s)             */
        for (int i = 0; i < this->Ne; i++) {
            this->baseptr[i].~T();
        }
        /* if reserve == false, then, free memory as usual */
        if (reserve == false) {
            if (baseptr) free(baseptr);
            baseptr = NULL;
            Ne = Me = 0;
        }
        else {
            /* otherwise we reserve memory */
            Ne = 0;
        }
    }
    int size() const { return this->Ne; }
    int cap() const { return this->Me; } /* return current maximum capacity */

    const T* data() const { return baseptr; }
    operator const T* () const { return baseptr; }

    bool isEmpty() { return (this->Ne == 0); }

    bool reserve(const int& size) {
        if (size < 1) return false;
        if (size <= Me) return true; /* already reserved */
        if (baseptr == NULL)
            baseptr = (T*)malloc(sizeof(T) * size);
        else
            baseptr = (T*)realloc(baseptr, sizeof(T) * size);
        if (baseptr == NULL) /* bad alloc */
            return false;
        Me = size;
        return true;
    }

protected:
    T* baseptr; /* data pointer */
    int Ne, Me; /* number of elements and max number of elements allowed */

protected:
    bool expandStorage() {
        if (Me == 0) { /* array is not initialized */
            Me = 16;
            baseptr = (T*)malloc(sizeof(T) * Me);
            if (baseptr == NULL)
                return false;
        }
        else {
            /* restrict 64MB memory increase per expansion */
            const int maxIncreaseBytesAllowed = 16 * 1024 * 1024; /* maximum 64MB per increase */
            int maxElementsIncrease = maxIncreaseBytesAllowed / sizeof(T);
            if (maxElementsIncrease < 2) maxElementsIncrease = 2;
            int newMe = int(double(Me) * 1.1);
            if (newMe - Me > maxElementsIncrease) {
                newMe = Me + maxElementsIncrease; /* limit increase amount */
            }
            baseptr = (T*)realloc(baseptr, sizeof(T) * newMe); /* expand size */
            Me = newMe;
            if (baseptr == NULL)
                return false;
        }
        return true;
    }
};

/* * * * * * * * * * * * * * * * * * * * * * * * */
/* generic stack implementation which is almost  */
/* identical to "Array" but has some differences */
/* * * * * * * * * * * * * * * * * * * * * * * * */
template <typename T>
class Stack {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions which are generated by the
    compilers.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

public:

    Stack() { baseptr = NULL; Ne = 0; Me = 0; }
    Stack(const Stack& that) {
        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty Stack */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* only initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if Stack element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }
    }
    virtual ~Stack() { this->clear(); }

    Stack& operator=(const Stack& that) {
        if (this == &that)
            return (*this); /* in case "a = a" will cause unexpected behavior */

        clear();

        this->Ne = that.Ne;
        this->Me = that.Me;
        /* initialize baseptr */
        if (that.Me == 0) { /* copy an empty Stack */
            this->baseptr = NULL;
        }
        else {
            this->baseptr = (T*)malloc(sizeof(T) * this->Me);
            /* only initialize used slots */
            for (int i = 0; i < this->Ne; i++) {
                new (&(this->baseptr[i])) T();
                /* may invoke overridden operator "=" if Stack element is */
                /* a class instance */
                this->baseptr[i] = that.baseptr[i];
            }
        }

        return (*this);
    }

public:

    bool push(const T& elem) {
        if (Ne == Me) {/* stack is full, expand it */
            if (expandStorage() == false)
                return false;
        }
        /* note: the current stack top may stored some elements
           before, which also may contains some trash data (such as
           some wild pointers, although the destructor has been
           called, the pointer value may not be set to NULL). If we
           directly assign "elem" to stack top these trash data will
           cause safety issues. So here we need to call constructor
           to initialize memory before assignment.
        */
        new (&(this->baseptr[Ne])) T(); /* init stack top and prepare
                                           for assignment later */
        baseptr[Ne] = elem;
        Ne++;
        return true; /* normally push() will always success */
    }
    bool pop(T& elem) {
        if (Ne == 0) {
            /* already empty, cannot pop any element */
            return false;
        }
        else {
            Ne--;
            elem = baseptr[Ne]; /* copy element from stack */
            baseptr[Ne].~T(); /* destroy element in stack */
            return true;
        }
    }
    bool pop() {
        if (Ne == 0) {
            /* already empty, cannot pop any element */
            return false;
        }
        else {
            Ne--;
            baseptr[Ne].~T(); /* destroy element in stack */
            return true;
        }
    }
    /* return stack top (instance is not popped out from stack) */
    T& top() const {
        return baseptr[Ne - 1];
    }
    void clear(bool reserve = false) {
        /* if each element in the Stack is a class instance,     */
        /* we need to manually call destructor for each instance */
        /* in order to release memory propoerly (especially when */
        /* class instance member contains pointer(s)             */
        for (int i = 0; i < this->Ne; i++) {
            this->baseptr[i].~T();
        }
        /* if reserve == false, then, free memory as usual */
        if (reserve == false) {
            if (baseptr) free(baseptr);
            baseptr = NULL;
            Ne = Me = 0;
        }
        else {
            /* otherwise we reserve memory */
            Ne = 0;
        }
    }
    int size() const { return this->Ne; }
    int cap() const { return this->Me; } /* return current maximum capacity */
    bool isEmpty() const { return (this->Ne == 0); }

    bool reserve(const int& size) {
        if (size < 1) return false;
        if (size <= Me) return true; /* already reserved */
        if (baseptr == NULL)
            baseptr = (T*)malloc(sizeof(T) * size);
        else
            baseptr = (T*)realloc(baseptr, sizeof(T) * size);
        if (baseptr == NULL) /* bad alloc */
            return false;
        Me = size;
        return true;
    }

    T& operator[](const int& i) {
        return baseptr[i];
    }
    const T& operator[](const int& i) const {
        return baseptr[i];
    }
    T& at(const int& i) {
        return baseptr[i];
    }
    const T& at(const int& i) const {
        return baseptr[i];
    }

protected:
    T* baseptr; /* data pointer */
    int Ne, Me; /* number of elements and max number of elements allowed */
protected:
    bool expandStorage() {
        if (Me == 0) { /* Stack is not initialized */
            Me = 16;
            baseptr = (T*)malloc(sizeof(T) * Me);
            if (baseptr == NULL)
                return false;
        }
        else {
            int maxIncreaseAllowed = 64 * 1024 * 1024; /* maximum 64MB per increase */
            int maxElementsIncrease = maxIncreaseAllowed / sizeof(T);
            int newMe = int(double(Me) * 1.1);
            if (maxElementsIncrease < 16) {
                maxElementsIncrease = 16;
            }
            if (newMe - Me > maxElementsIncrease) {
                newMe = Me + maxElementsIncrease; /* limit increase amount */
            }
            baseptr = (T*)realloc(baseptr, sizeof(T) * newMe); /* expand size */
            Me = newMe;
            if (baseptr == NULL)
                return false;
        }
        return true;
    }
};

/* * * * * * * * * * * * * * * * * * * * * */
/* generic fixed size queue implementation */
/* * * * * * * * * * * * * * * * * * * * * */
template <typename T>
class FixedQueue {

    /*

    IMPORTANT NOTE:

    If "T" is a class rather than a pure data structure, then T must
    implement the following functions for correctly initializing/free
    memory spaces. I strongly recommend you to implement them manually
    and don't use the their default versions which are generated by the
    compilers.

    1) a DEFAULT constructor:         T::T().
    2) a (virtual) destructor:        (virtual) T::~T().
    3) a copy constructor:            T::T(const T&)().
    4) an overloaded operator "=":    T& operator=(const T&).

    */

    /* looped queue

    index:   0   1   2   3   4   ...   Me-1
     used:   n   n   y   y   n   ...   n
    Qstart = 2
      Qend = 4

    */

public:
    FixedQueue() {
        baseptr = NULL;
        Me = 0;
        Qstart = -1; Qend = -1;
    }
    virtual ~FixedQueue() {
        purge();
    }
    FixedQueue(const FixedQueue& that) {
        Me = that.Me;
        Qstart = that.Qstart;
        Qend = that.Qend;
        baseptr = (T*)malloc(sizeof(T) * Me);
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            new (this->baseptr + i) T();
            baseptr[i] = that.baseptr[i];
        }
    }

    FixedQueue& operator=(const FixedQueue& that) {
        if (this == &that)
            return (*this);
        purge();

        Me = that.Me;
        Qstart = that.Qstart;
        Qend = that.Qend;
        baseptr = (T*)malloc(sizeof(T) * Me);
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            new (this->baseptr + i) T();
            baseptr[i] = that.baseptr[i];
        }

        return (*this);
    }

public:
    /* create a queue with n slots */
    bool create(const int& maxSize) {
        if (maxSize <= 0) return false;
        if (baseptr)
            purge();
        Me = maxSize + 1;
        baseptr = (T*)malloc(sizeof(T)*Me); /* reserve one slot unused */
        if (baseptr == NULL)
            return false;
        Qstart = 0;
        Qend = 0;
        return true;
    }
    /* put an element of type T into queue, return false if queue is full */
    bool put(const T& elem) {
        if (nextIndex(Qend) == Qstart || baseptr == NULL) {
            return false; /* queue is full or not initialized */
        }
        new (this->baseptr + Qend) T();
        baseptr[Qend] = elem;
        Qend = nextIndex(Qend);
        return true;
    }
    /* get an element of type T from queue, return false if queue is empty */
    bool get(T& elem) {
        if (Qstart == Qend || baseptr == NULL) {
            return false; /* queue is empty */
        }
        elem = baseptr[Qstart];
        baseptr[Qstart].~T();
        Qstart = nextIndex(Qstart);
        return true;
    }
    /* check if queue is full/empty */
    bool isFull() { return sizeUsed() == sizeMax(); }
    bool isEmpty() { return sizeUsed() == 0; }
    /* clear the entire queue (but keep all slots remained) */
    void clear() {
        /* delete current elements in queue */
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            baseptr[i].~T();
        }
        /* reset all counters */
        Qstart = Qend = 0;
    }
    /* get the number of elements currently stored in queue */
    int sizeUsed() const {
        if (Qend >= Qstart)
            return Qend - Qstart;
        else {
            return Me - Qstart + Qend;
        }
    }
    /* get the maximum number of elements this queue can store */
    int sizeMax() const { return Me - 1 < 0 ? 0 : Me - 1; }

    T& at(const int& index) {
        int Qidx = Qstart;
        for (int i = 0; i < index; i++)
            Qidx = nextIndex(Qidx);
        return baseptr[Qidx];
    }
    const T& at(const int& index) const {
        int Qidx = Qstart;
        for (int i = 0; i < index; i++)
            Qidx = nextIndex(Qidx);
        return baseptr[Qidx];
    }
    T& operator[](const int& index) {
        int Qidx = Qstart;
        for (int i = 0; i < index; i++)
            Qidx = nextIndex(Qidx);
        return baseptr[Qidx];
    }
    const T& operator[](const int& index) const {
        int Qidx = Qstart;
        for (int i = 0; i < index; i++)
            Qidx = nextIndex(Qidx);
        return baseptr[Qidx];
    }

protected:
    /* delete the queue (only for internal use, completely removes the
       whole queue and free allocated memory) */
    void purge() {
        /* delete current elements in queue */
        for (int i = Qstart; i != Qend; i = nextIndex(i)) {
            baseptr[i].~T();
        }
        if (baseptr) {
            free(baseptr);
            baseptr = NULL;
        }
        Me = 0;
        Qstart = -1; Qend = -1;
    }
    int nextIndex(int currentIndex) const {
        if (currentIndex < 0 || currentIndex >= Me) return -1;
        else if (currentIndex == Me - 1) return 0;
        else return currentIndex + 1;
    }
    int prevIndex(int currentIndex) const {
        if (currentIndex < 0 || currentIndex >= Me) return -1;
        else if (currentIndex == 0) return Me - 1;
        else return currentIndex - 1;
    }

protected:
    T* baseptr;
    int Me; /* 1 + maximum number of elements */
    int Qstart, Qend;

};

template <typename T>
class MaxHeap 
{
protected:
    Array<T> arr;
protected:
    int  parent(const int& index) const { return (index - 1) / 2; }
    int  leftChild(const int& index) const { return index * 2 + 1; }
    int  rightChild(const int& index) const { return index * 2 + 2; }
    void siftUp(int index) {
        while (index > 0)
        {
            int parentIndex = parent(index);
            if (arr[index] > arr[parentIndex])
                swap(arr[index], arr[parentIndex]);
            else
                break;
            index = parentIndex;
        }
    }
    void siftDown(int index) {
        while (index < size())
        {
            int leftIndex = leftChild(index);
            int rightIndex = rightChild(index);
            int swapIndex = size(); /* init invalid value */
            if (rightIndex < size() && arr[leftIndex] < arr[rightIndex])
                /* if right child exist, and left < right */
                swapIndex = rightIndex;
            else if (leftIndex < size())
                /* else (right not exist or left >= right) if left child exist, then */
                swapIndex = leftIndex;
            else
                /* no left or right child, we reach the leaf node */
                break; /* sift down complete */
            if (arr[index] > arr[swapIndex])
                break;
            else
                swap(arr[index], arr[swapIndex]);
            index = swapIndex;
        }
    }
public:
    MaxHeap() {}
    virtual ~MaxHeap() {}

    int  size() const { return this->arr.size(); }
    bool isEmpty() const { return (size() == 0); }
    bool get(T& elem) {
        if (isEmpty())
            return false;
        elem = arr[0];
        arr[0] = arr.last();
        arr.popLast();
        siftDown(0);
        return true;
    }
    /* put an element into heap and pop max element */
    bool replace(T& elem) {
        if (isEmpty())
            return false;
        T maxElem = arr[0];
        arr[0] = elem;
        elem = maxElem;
        siftDown(0);
        return true;
    }
    bool put(const T& elem) {
        if ((arr.append(elem)) == false)
            return false;
        siftUp(size() - 1);
        return true;
    }
    /* check the max item but not remove it */
    bool query(T& elem) const {
        if (isEmpty()) return false;
        elem = arr[0];
        return true;
    }
    void heapify(const Array<T> & arr) {
        this->arr = arr;
        if (this->arr.size() <= 1) return;
        /* start from last non-leaf node */
        int lastNonLeaf = parent(this->arr.size() - 1);
        for (int i = lastNonLeaf; i >= 0; i--) {
            siftDown(i);
        }
    }

    T& operator [] (const int& index) {
        return arr[index];
    }
    const T& operator [] (const int& index) const {
        return arr[index];
    }

    void debugPrint()
    {
        int lvlMaxId = 0;
        for (int i = 0; i < size(); i++) {
            printf("%d ", arr[i]);
            if (i == lvlMaxId) {
                lvlMaxId = lvlMaxId * 2 + 2;
                printf("\n");
            }
        }
        printf("\n\n");
    }
};

template <typename _storage_t, typename _priority_t>
class PriorityQueue 
{
protected:
    template <typename _storage_t, typename _priority_t>
    struct _Item_
    {
        _storage_t  storage;
        _priority_t priority;
        bool operator > (const _Item_& rhs) { return (this->priority > rhs.priority); }
        bool operator < (const _Item_& rhs) { return (this->priority < rhs.priority); }
    };
protected:
    MaxHeap<_Item_<_storage_t, _priority_t>> heap;

public:
    PriorityQueue() {};
    virtual ~PriorityQueue() {};

    bool isEmpty() const { return heap.isEmpty(); }
    int size() const { return heap.size(); }

    bool put(const _storage_t& item, const _priority_t& priority)
    {
        _Item_< _storage_t, _priority_t> heapItem;
        heapItem.priority = priority;
        heapItem.storage = item;
        return heap.put(heapItem);
    }
    bool get(_storage_t& item)
    {
        _Item_< _storage_t, _priority_t> heapItem;
        bool success = heap.get(heapItem);
        if (success) {
            item = heapItem.storage;
        }
        return success;
    }
    bool get(_storage_t& item, _priority_t& priority)
    {
        _Item_< _storage_t, _priority_t> heapItem;
        bool success = heap.get(heapItem);
        if (success) {
            item = heapItem.storage;
            priority = heapItem.priority;
        }
        return success;
    }
    bool replace(_storage_t& item, _priority_t& priority)
    {
        _Item_< _storage_t, _priority_t> heapItem;
        heapItem.priority = priority;
        heapItem.storage = item;
        bool success = heap.replace(heapItem);
        return success;
    }
    bool query(_storage_t& item, _priority_t& priority) const
    {
        _Item_< _storage_t, _priority_t> heapItem;
        bool success = heap.query(heapItem);
        item = heapItem.storage;
        priority = heapItem.priority;
        return success;
    }

    _storage_t& operator [] (const int& index) {
        return heap[index].storage;
    }
    const _storage_t& operator [] (const int& index) const {
        return heap[index].storage;
    }

};

/* * * * * * * * * * * * * * * * * * * * * * * * * * */
/* implement noncopyable feature, if you want your   */
/* class to be noncopyable simply inherit this class */
/* * * * * * * * * * * * * * * * * * * * * * * * * * */
class Noncopyable
{
    /* Although I give them implementation, they are declared as private */
    /* and cannot be called externally, so they are actually disabled.   */
private:
    Noncopyable(const Noncopyable&) {}
    const Noncopyable& operator=(const Noncopyable&) { return (*this); }
protected:
    Noncopyable() {}
    ~Noncopyable() {} /* don't need to declare this as virtual */
};

class String : protected Array<char> {
public:
    String();
    String(const String&);
    String(const char*);
    String operator = (const String&);
    String operator = (const char*);
    virtual ~String();

    bool operator == (const char*);
    bool operator == (const String&);
    int length() const;
    const char* c_str() const;

    operator const char* () const;

    String operator + (const String& s) const;
    String operator += (const String& s);
};

/* * * * * * * * * * * * * * * * */
/* basic file/string operations  */
/* * * * * * * * * * * * * * * * */
/* check if a certain character is in a string */
bool chInStr(const char ch, const char* s);
/* remove char from a string */
void strRemCh(const char* src, char* buf, int bufLen, char ch);
/* get a single word from file/string, each word */
/* is separated by every character in wordDelim  */
/* => only returns when a non-empty valid word is found */
/* if no valid word can be found, it will return false  */
/* otherwise it will return true to indicate there are  */
/* possibly still some valid words remaining in string  */
bool txtGetWord(FILE* fp, char* buf, int bufLen, const char* wordDelim, const char commentChar);
bool strGetWord(char* src, char* buf, int bufLen, const char* wordDelim, const char commentChar);
bool txtGetLine(FILE* fp, char* buf, int bufLen);
/* load basic data types from a text file */
bool txtGetReal(FILE* fp, REAL* v); /* load a floating point number from file stream */
bool txtGetInt(FILE* fp, int* v);   /* load an integer from file stream */
bool txtGetVec2(FILE* fp, VEC2* v); /* load two floating point numbers from file stream */
bool txtGetVec3(FILE* fp, VEC3* v); /* load three floating point numbers from file stream */
bool txtGetInt2(FILE* fp, INT2* v); /* load two integers from file stream */
bool txtGetInt3(FILE* fp, INT3* v); /* load three integers from file stream */
/* load all characters from a text file */
bool loadTextFile(char* file, char* buf, int bufLen);
/* byte array operations */
Array<BYTE> loadAsByteArray(const char* file);
bool saveByteArray(const Array<BYTE>& byteArray, const char* file);
/* helper functions */
void printVec3(const char* prefix, VEC3 v);
void printVec4(const char * prefix, VEC4 v);
void printMat3x3(const char* prefix, MAT3x3 m);
void printMat4x4(const char * prefix, MAT4x4 m);
void printQuaternion(const char* prefix, QUAT q);
void printByteArray(const Array<BYTE>& byteArray);
